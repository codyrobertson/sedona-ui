{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "swap-utils",
  "type": "registry:lib",
  "title": "Swap Utilities",
  "description": "Utilities for swap interfaces: number formatting, input sanitization, slippage calculations",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "lib/swap-utils.ts",
      "type": "registry:lib",
      "content": "/**\n * Swap Widget Utilities\n * Extracted from swap-widget.tsx for reusability and testability\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface Token {\n  symbol: string\n  name: string\n  imageUrl?: string\n  decimals?: number\n  balance: string\n  price: number\n  isNative?: boolean\n  minAmount?: string\n  maxAmount?: string\n}\n\nexport interface SwapQuote {\n  inputAmount: string\n  outputAmount: string\n  rate: number\n  priceImpact: number\n  fee: number\n  route?: string[]\n}\n\n/**\n * Format a number with thousand separators and optional decimal truncation\n * @param value - Number or string to format\n * @param maxDecimals - Maximum decimal places (default: 6)\n * @returns Formatted string\n */\nexport function formatNumber(value: string | number, maxDecimals = 6): string {\n  if (value === \"\" || value === undefined) return \"\"\n  const num = typeof value === \"string\" ? parseFloat(value) : value\n  if (isNaN(num)) return \"\"\n  if (num > 0 && num < 0.000001) return num.toExponential(2)\n\n  const parts = num.toFixed(maxDecimals).split(\".\")\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\")\n  if (parts[1]) {\n    parts[1] = parts[1].replace(/0+$/, \"\")\n    if (parts[1] === \"\") return parts[0]\n  }\n  return parts.join(\".\")\n}\n\n/**\n * Format a number as USD currency\n * @param value - Number to format\n * @returns Formatted USD string\n */\nexport function formatUSD(value: number): string {\n  if (isNaN(value)) return \"$0\"\n  if (value < 0.01 && value > 0) return \"<$0.01\"\n  if (value === 0) return \"$0\"\n  if (value >= 1000000) return `$${(value / 1000000).toFixed(2)}M`\n  if (value >= 1000) return `$${(value / 1000).toFixed(2)}K`\n  return `$${value.toFixed(2)}`\n}\n\n/**\n * Sanitize user input for numeric fields\n * - Removes non-numeric characters (except decimal point)\n * - Handles multiple decimal points\n * - Enforces max decimal places\n * - Strips leading zeros\n *\n * @param value - Raw input string\n * @param maxDecimals - Maximum decimal places allowed (default: 9)\n * @returns Sanitized numeric string\n */\nexport function sanitizeNumericInput(value: string, maxDecimals = 9): string {\n  let sanitized = value.replace(/[^0-9.]/g, \"\")\n  const parts = sanitized.split(\".\")\n  if (parts.length > 2) sanitized = parts[0] + \".\" + parts.slice(1).join(\"\")\n  if (parts.length === 2 && parts[1].length > maxDecimals) {\n    sanitized = parts[0] + \".\" + parts[1].slice(0, maxDecimals)\n  }\n  if (sanitized.length > 1 && sanitized[0] === \"0\" && sanitized[1] !== \".\") {\n    sanitized = sanitized.replace(/^0+/, \"\") || \"0\"\n    // Prepend 0 if result starts with decimal\n    if (sanitized[0] === \".\") {\n      sanitized = \"0\" + sanitized\n    }\n  }\n  return sanitized\n}\n\n/**\n * Parse a balance string that may contain formatting (commas, spaces)\n * @param balance - Formatted balance string\n * @returns Numeric value\n */\nexport function parseBalance(balance: string): number {\n  const cleaned = balance.replace(/[,\\s]/g, \"\")\n  return parseFloat(cleaned) || 0\n}\n\n/**\n * Calculate slippage multiplier from slippage string\n * @param slippage - Slippage value (\"Auto\" or percentage like \"1.0\")\n * @returns Multiplier (e.g., 0.99 for 1% slippage)\n */\nexport function getSlippageMultiplier(slippage: string): number {\n  if (slippage === \"Auto\") return 0.995 // Default 0.5% for auto\n  const pct = parseFloat(slippage)\n  if (isNaN(pct)) return 0.995\n  return 1 - (pct / 100)\n}\n\n/**\n * Calculate minimum received amount after slippage\n * @param amount - Expected receive amount\n * @param slippage - Slippage setting\n * @returns Minimum amount after slippage\n */\nexport function calculateMinReceived(amount: string | number, slippage: string): string {\n  const amountNum = typeof amount === \"string\" ? parseFloat(amount) : amount\n  if (isNaN(amountNum)) return \"0\"\n  const multiplier = getSlippageMultiplier(slippage)\n  return (amountNum * multiplier).toFixed(6)\n}\n\n/**\n * Validate trade amount against constraints\n * @param amount - Amount to validate\n * @param balance - Available balance\n * @param options - Validation options\n * @returns Validation result with error message if invalid\n */\nexport function validateTradeAmount(\n  amount: number,\n  balance: number,\n  options: {\n    isNative?: boolean\n    gasReserve?: number\n    minAmount?: number\n    maxAmount?: number\n  } = {}\n): { valid: boolean; error?: string } {\n  const { isNative = false, gasReserve = 0.01, minAmount, maxAmount } = options\n\n  if (amount <= 0) {\n    return { valid: false, error: \"Enter an amount\" }\n  }\n\n  if (amount > balance) {\n    return { valid: false, error: \"Insufficient balance\" }\n  }\n\n  if (isNative && amount > balance - gasReserve) {\n    return { valid: false, error: `Reserve ${gasReserve} for gas` }\n  }\n\n  if (minAmount !== undefined && amount < minAmount) {\n    return { valid: false, error: `Minimum amount is ${minAmount}` }\n  }\n\n  if (maxAmount !== undefined && amount > maxAmount) {\n    return { valid: false, error: `Maximum amount is ${maxAmount}` }\n  }\n\n  return { valid: true }\n}\n\n/**\n * Calculate price impact color based on percentage\n * @param impact - Price impact percentage\n * @returns Tailwind color class\n */\nexport function getPriceImpactColor(impact: number): string {\n  if (impact < 1) return \"text-zeus-status-success\"\n  if (impact < 5) return \"text-zeus-status-warning\"\n  return \"text-zeus-status-destructive\"\n}\n\n/**\n * Format price impact for display\n * @param impact - Price impact percentage\n * @returns Formatted string\n */\nexport function formatPriceImpact(impact: number): string {\n  if (impact < 0.01) return \"<0.01%\"\n  return `${impact.toFixed(2)}%`\n}\n"
    }
  ]
}